"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlanResultCacheService = void 0;
var GetPlanBooleanOptionsMask;
(function (GetPlanBooleanOptionsMask) {
    GetPlanBooleanOptionsMask[GetPlanBooleanOptionsMask["singleMandatory"] = 0] = "singleMandatory";
    GetPlanBooleanOptionsMask[GetPlanBooleanOptionsMask["singleOptional"] = 1] = "singleOptional";
    GetPlanBooleanOptionsMask[GetPlanBooleanOptionsMask["multipleMandatory"] = 2] = "multipleMandatory";
    GetPlanBooleanOptionsMask[GetPlanBooleanOptionsMask["multipleOptional"] = 3] = "multipleOptional";
    // Must be the last one
    GetPlanBooleanOptionsMask[GetPlanBooleanOptionsMask["length"] = 4] = "length";
})(GetPlanBooleanOptionsMask || (GetPlanBooleanOptionsMask = {}));
/**
 * Service to cache plans.
 *
 * This class is used to cache plans and to notify PlanService subscribers when the cache is cleared.
 * The cache should be cleared when a new binding is registered or when a binding is unregistered.
 *
 * Subscribers are supposed to be plan services from child containers.
 *
 * Ancestor binding constraints are the reason to avoid reusing plans from plan children nodes.
 */
class PlanResultCacheService {
    #serviceIdToValuePlanMap;
    #namedServiceIdToValuePlanMap;
    #taggedServiceIdToValuePlanMap;
    #namedTaggedServiceIdToValuePlanMap;
    #subscribers;
    constructor() {
        this.#serviceIdToValuePlanMap = this.#buildInitializedMapArray();
        this.#namedServiceIdToValuePlanMap = this.#buildInitializedMapArray();
        this.#namedTaggedServiceIdToValuePlanMap = this.#buildInitializedMapArray();
        this.#taggedServiceIdToValuePlanMap = this.#buildInitializedMapArray();
        this.#subscribers = [];
    }
    clearCache() {
        for (const map of this.#getMaps()) {
            map.clear();
        }
        for (const subscriber of this.#subscribers) {
            subscriber.clearCache();
        }
    }
    get(options) {
        if (options.name === undefined) {
            if (options.tag === undefined) {
                return this.#getMapFromMapArray(this.#serviceIdToValuePlanMap, options).get(options.serviceIdentifier);
            }
            else {
                return this.#getMapFromMapArray(this.#taggedServiceIdToValuePlanMap, options)
                    .get(options.serviceIdentifier)
                    ?.get(options.tag.key)
                    ?.get(options.tag.value);
            }
        }
        else {
            if (options.tag === undefined) {
                return this.#getMapFromMapArray(this.#namedServiceIdToValuePlanMap, options)
                    .get(options.serviceIdentifier)
                    ?.get(options.name);
            }
            else {
                return this.#getMapFromMapArray(this.#namedTaggedServiceIdToValuePlanMap, options)
                    .get(options.serviceIdentifier)
                    ?.get(options.name)
                    ?.get(options.tag.key)
                    ?.get(options.tag.value);
            }
        }
    }
    set(options, planResult) {
        if (options.name === undefined) {
            if (options.tag === undefined) {
                this.#getMapFromMapArray(this.#serviceIdToValuePlanMap, options).set(options.serviceIdentifier, planResult);
            }
            else {
                this.#getOrBuildMapValueFromMapMap(this.#getOrBuildMapValueFromMapMap(this.#getMapFromMapArray(this.#taggedServiceIdToValuePlanMap, options), options.serviceIdentifier), options.tag.key).set(options.tag.value, planResult);
            }
        }
        else {
            if (options.tag === undefined) {
                this.#getOrBuildMapValueFromMapMap(this.#getMapFromMapArray(this.#namedServiceIdToValuePlanMap, options), options.serviceIdentifier).set(options.name, planResult);
            }
            else {
                this.#getOrBuildMapValueFromMapMap(this.#getOrBuildMapValueFromMapMap(this.#getOrBuildMapValueFromMapMap(this.#getMapFromMapArray(this.#namedTaggedServiceIdToValuePlanMap, options), options.serviceIdentifier), options.name), options.tag.key).set(options.tag.value, planResult);
            }
        }
    }
    subscribe(subscriber) {
        this.#subscribers.push(subscriber);
    }
    #buildInitializedMapArray() {
        const mapArray = new Array(GetPlanBooleanOptionsMask.length);
        for (let i = 0; i < mapArray.length; ++i) {
            mapArray[i] = new Map();
        }
        return mapArray;
    }
    #getOrBuildMapValueFromMapMap(map, key) {
        let valueMap = map.get(key);
        if (valueMap === undefined) {
            valueMap = new Map();
            map.set(key, valueMap);
        }
        return valueMap;
    }
    #getMapFromMapArray(mapArray, options) {
        return mapArray[this.#getMapArrayIndex(options)];
    }
    #getMaps() {
        return [
            ...this.#serviceIdToValuePlanMap,
            ...this.#namedServiceIdToValuePlanMap,
            ...this.#namedTaggedServiceIdToValuePlanMap,
            ...this.#taggedServiceIdToValuePlanMap,
        ];
    }
    #getMapArrayIndex(options) {
        if (options.isMultiple) {
            if (options.optional === true) {
                return GetPlanBooleanOptionsMask.multipleOptional;
            }
            else {
                return GetPlanBooleanOptionsMask.multipleMandatory;
            }
        }
        else {
            if (options.optional === true) {
                return GetPlanBooleanOptionsMask.singleOptional;
            }
            else {
                return GetPlanBooleanOptionsMask.singleMandatory;
            }
        }
    }
}
exports.PlanResultCacheService = PlanResultCacheService;
//# sourceMappingURL=PlanResultCacheService.js.map